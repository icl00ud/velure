# Example: PgBouncer as Sidecar Container
# This shows how to run PgBouncer alongside your application pod

apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-service-with-pgbouncer
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: auth-service
  template:
    metadata:
      labels:
        app: auth-service
    spec:
      containers:
      # Main application container
      - name: auth-service
        image: icl00ud/velure-auth:latest
        ports:
        - containerPort: 3020
        env:
        # Connect to localhost:6432 (PgBouncer sidecar)
        - name: POSTGRES_HOST
          value: "localhost"
        - name: POSTGRES_PORT
          value: "6432"  # PgBouncer port
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: username
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: password
        - name: POSTGRES_DB
          value: "velure_auth"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"

      # PgBouncer sidecar container
      - name: pgbouncer
        image: edoburu/pgbouncer:1.21.0
        ports:
        - name: pgbouncer
          containerPort: 6432  # Different port to avoid conflict
        env:
        - name: DB_HOST
          value: "velure-production-auth.cw9gu66melkv.us-east-1.rds.amazonaws.com"
        - name: DB_PORT
          value: "5432"
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: password
        - name: POOL_MODE
          value: "transaction"
        - name: MAX_CLIENT_CONN
          value: "100"
        - name: DEFAULT_POOL_SIZE
          value: "5"  # Only 5 real connections per pod
        - name: MIN_POOL_SIZE
          value: "2"
        - name: RESERVE_POOL_SIZE
          value: "2"
        - name: SERVER_LIFETIME
          value: "3600"
        - name: SERVER_IDLE_TIMEOUT
          value: "600"
        resources:
          requests:
            memory: "32Mi"
            cpu: "50m"
          limits:
            memory: "64Mi"
            cpu: "100m"
        livenessProbe:
          tcpSocket:
            port: 6432
          initialDelaySeconds: 10
          periodSeconds: 30
        readinessProbe:
          tcpSocket:
            port: 6432
          initialDelaySeconds: 5
          periodSeconds: 10

---
# Example: Using ConfigMap for custom PgBouncer config in sidecar
apiVersion: v1
kind: ConfigMap
metadata:
  name: pgbouncer-sidecar-config
data:
  pgbouncer.ini: |
    [databases]
    velure_auth = host=$(DB_HOST) port=5432 dbname=velure_auth

    [pgbouncer]
    listen_addr = 0.0.0.0
    listen_port = 6432
    auth_type = md5
    auth_file = /etc/pgbouncer/userlist.txt
    pool_mode = transaction
    max_client_conn = 100
    default_pool_size = 5
    min_pool_size = 2
    reserve_pool_size = 2
    server_lifetime = 3600
    server_idle_timeout = 600
    log_connections = 1
    log_disconnections = 1
    server_check_query = SELECT 1
    server_check_delay = 30

  userlist.txt: |
    "postgres" "md5placeholder"

---
# Pros of Sidecar Approach:
# ✅ Isolation - Each service has its own PgBouncer
# ✅ Ultra-low latency - localhost connection
# ✅ No single point of failure
# ✅ Independent scaling
#
# Cons of Sidecar Approach:
# ⚠️ More resource usage - 1 PgBouncer per pod
# ⚠️ More connections to RDS - N pods × pool_size
# ⚠️ Harder to manage - N PgBouncers to monitor
# ⚠️ Harder to update - Need to update all deployments
#
# Recommendation:
# Use centralized PgBouncer (deployment.yaml) instead of sidecar
# unless you have specific isolation requirements.
